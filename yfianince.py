# -*- coding: utf-8 -*-
"""yfianince.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IDCN8uFxcsBc6xdz2NCFFZZI13k4eePv
"""

! pip install yfinance --upgrade --no-cache-dir

! pip install yfinance

!pip install requests_cache
!pip install requests-ratelimiter

import yfinance as yf

tickers = yf.Tickers('msft aapl goog')

# access each ticker using (example)
tickers.tickers['MSFT'].info
tickers.tickers['AAPL'].history(period="1mo")
tickers.tickers['GOOG'].actions

import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

import yfinance as yf

msft = yf.Ticker("MSFT")

msft.get_actions(proxy="PROXY_SERVER")
msft.get_dividends(proxy="PROXY_SERVER")
msft.get_splits(proxy="PROXY_SERVER")
msft.get_capital_gains(proxy="PROXY_SERVER")
msft.get_balance_sheet(proxy="PROXY_SERVER")
msft.get_cashflow(proxy="PROXY_SERVER")

import yfinance as yf
data = yf.download("SPY AAPL", period="1mo")

import requests_cache
session = requests_cache.CachedSession('yfinance.cache')
session.headers['User-agent'] = 'my-program/1.0'
ticker = yf.Ticker('msft', session=session)
ticker.actions

from requests import Session
from requests_cache import CacheMixin, SQLiteCache
from requests_ratelimiter import LimiterMixin, MemoryQueueBucket
from pyrate_limiter import Duration, RequestRate, Limiter
class CachedLimiterSession(CacheMixin, LimiterMixin, Session):
    pass

session = CachedLimiterSession(
    limiter=Limiter(RequestRate(2, Duration.SECOND*5)),
    bucket_class=MemoryQueueBucket,
    backend=SQLiteCache("yfinance.cache"),
)

# Define the ticker symbol
ticker_symbol = "AAPL"  # Apple Inc.

# Fetch the ticker data
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data
print(historical_data.head())

# Create a new column for the target variable (next dayâ€™s closing price)
historical_data['Target'] = historical_data['Close'].shift(-1)

# Drop the last row (as it will have NaN in the 'Target' column)
historical_data = historical_data[:-1]

# Use only the 'Close' prices to predict the next day's 'Close' price
X = historical_data[['Close']]
y = historical_data['Target']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the Random Forest Regressor
model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
model.fit(X_train, y_train)

# Make predictions
predictions = model.predict(X_test)

# Calculate the Mean Squared Error
mse = mean_squared_error(y_test, predictions)
print(f"Mean Squared Error: {mse:.4f}")

# Plot actual vs. predicted prices
plt.figure(figsize=(10, 6))
plt.plot(y_test.values, label='Actual Prices', alpha=0.7)
plt.plot(predictions, label='Predicted Prices', alpha=0.7)
plt.title("Actual vs. Predicted Stock Prices")
plt.xlabel("Days")
plt.ylabel("Price (USD)")
plt.legend()
plt.show()

# Install TensorFlow and Keras
!pip install tensorflow

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from sklearn.preprocessing import MinMaxScaler

# Scale the data to be between 0 and 1
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(historical_data[['Close']])

# Prepare the data for LSTM
X = []
y = []
for i in range(60, len(scaled_data)):
    X.append(scaled_data[i-60:i, 0])
    y.append(scaled_data[i, 0])

X, y = np.array(X), np.array(y)
X = np.reshape(X, (X.shape[0], X.shape[1], 1))

# Split into training and testing sets
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Build the LSTM model
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
    Dropout(0.2),
    LSTM(50, return_sequences=False),
    Dropout(0.2),
    Dense(25),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X_train, y_train, batch_size=1, epochs=1)

# Predict and evaluate
predictions = model.predict(X_test)
predictions = scaler.inverse_transform(predictions)

# Define the ticker symbol for Amazon.com, Inc.
ticker_symbol = "AMZN"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data
print(historical_data.head())

# Define the ticker symbol for Tata Power on NSE
ticker_symbol = "TATAPOWER.NS"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data
print(historical_data.head())

# Define the ticker symbol for Tata Power on NSE
ticker_symbol = "TATAPOWER.NS"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
data = ticker_data.history(period="2y")

# Define the support and resistance levels dictionary
levels = {"Support": [], "Resistance": []}

# Define the range for identifying support and resistance levels
high_range = data['High'].max() * 0.98  # Example: 98% of the highest high
low_range = data['Low'].min() * 1.02    # Example: 102% of the lowest low

# Loop through the data to identify support and resistance levels
for i in range(len(data)):
    if data['High'].iloc[i] >= high_range:
        levels["Resistance"].append(data['High'].iloc[i])
    if data['Low'].iloc[i] <= low_range:
        levels["Support"].append(data['Low'].iloc[i])

# Print identified support and resistance levels
print("Identified Support Levels:", levels["Support"])
print("Identified Resistance Levels:", levels["Resistance"])

# Support and Resistance Levels
levels = {"Support": [], "Resistance": []}

for i in range(len(data)):
    if data['High'].iloc[i] == high_range:
        levels["Resistance"].append(data['High'].iloc[i])
    if data['Low'].iloc[i] == low_range:
        levels["Support"].append(data['Low'].iloc[i])

# Define the ticker symbol for Tata Power on NSE
ticker_symbol = "TATAPOWER.NS"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
data = ticker_data.history(period="2y")

# Display the first few rows of the historical data to understand the structure
print(data.head())

# Define the range for identifying support and resistance levels
high_range = data['High'].max()  # The highest price reached in the period
low_range = data['Low'].min()    # The lowest price reached in the period

# Initialize a dictionary to store support and resistance levels
levels = {"Support": [], "Resistance": []}

# Loop through the data to identify support and resistance levels
for i in range(len(data)):
    if data['High'].iloc[i] == high_range:
        levels["Resistance"].append(data['High'].iloc[i])
    if data['Low'].iloc[i] == low_range:
        levels["Support"].append(data['Low'].iloc[i])

# Print identified support and resistance levels
print("Identified Support Levels:", levels["Support"])
print("Identified Resistance Levels:", levels["Resistance"])

# Define the ticker symbol for Amazon.com, Inc.
ticker_symbol = "AMZN"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data to understand the structure
print(historical_data.head())

# Define the range for identifying support and resistance levels
high_range = historical_data['High'].max()  # The highest price reached in the period
low_range = historical_data['Low'].min()    # The lowest price reached in the period

# Initialize a dictionary to store support and resistance levels
levels = {"Support": [], "Resistance": []}

# Loop through the data to identify support and resistance levels
for i in range(len(historical_data)):
    if historical_data['High'].iloc[i] == high_range:
        levels["Resistance"].append(historical_data['High'].iloc[i])
    if historical_data['Low'].iloc[i] == low_range:
        levels["Support"].append(historical_data['Low'].iloc[i])

# Print identified support and resistance levels
print("Identified Support Levels:", levels["Support"])
print("Identified Resistance Levels:", levels["Resistance"])

ticker_symbol = "GS"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data to understand the structure
print(historical_data.head())

# Define the range for identifying support and resistance levels
high_range = historical_data['High'].max()  # The highest price reached in the period
low_range = historical_data['Low'].min()    # The lowest price reached in the period

# Initialize a dictionary to store support and resistance levels
levels = {"Support": [], "Resistance": []}

# Loop through the data to identify support and resistance levels
for i in range(len(historical_data)):
    if historical_data['High'].iloc[i] == high_range:
        levels["Resistance"].append(historical_data['High'].iloc[i])
    if historical_data['Low'].iloc[i] == low_range:
        levels["Support"].append(historical_data['Low'].iloc[i])

# Print identified support and resistance levels
print("Identified Support Levels:", levels["Support"])
print("Identified Resistance Levels:", levels["Resistance"])

# Define the ticker symbol for Tata Steel on NSE
ticker_symbol = "TATASTEEL.NS"

# Fetch the data for the given ticker symbol
ticker_data = yf.Ticker(ticker_symbol)

# Download historical data (e.g., last 2 years of daily data)
historical_data = ticker_data.history(period="2y")

# Display the first few rows of the historical data to understand the structure
print(historical_data.head())

# Define the range for identifying support and resistance levels
high_range = historical_data['High'].max()  # The highest price reached in the period
low_range = historical_data['Low'].min()    # The lowest price reached in the period

# Initialize a dictionary to store support and resistance levels
levels = {"Support": [], "Resistance": []}

# Loop through the data to identify support and resistance levels
for i in range(len(historical_data)):
    if historical_data['High'].iloc[i] == high_range:
        levels["Resistance"].append(historical_data['High'].iloc[i])
    if historical_data['Low'].iloc[i] == low_range:
        levels["Support"].append(historical_data['Low'].iloc[i])

# Print identified support and resistance levels
print("Identified Support Levels:", levels["Support"])
print("Identified Resistance Levels:", levels["Resistance"])





# Function to fetch data and perform analysis
def stock_analysis(ticker_symbol):
    # Fetch the data for the given ticker symbol
    ticker_data = yf.Ticker(ticker_symbol)

    # Download historical data (e.g., last 1 year of daily data)
    historical_data = ticker_data.history(period="1y")

    # Check if historical data is available
    if historical_data.empty:
        print(f"No data found for ticker: {ticker_symbol}")
        return

    # Display the first few rows of the historical data
    print(f"Historical Data for {ticker_symbol}:\n", historical_data.head())

    # Calculate moving averages
    historical_data['Short_MA'] = historical_data['Close'].rolling(window=20).mean()  # 20-day moving average
    historical_data['Long_MA'] = historical_data['Close'].rolling(window=50).mean()  # 50-day moving average

    # Calculate Fibonacci retracement levels
    max_price = historical_data['High'].max()
    min_price = historical_data['Low'].min()
    difference = max_price - min_price
    levels = {
        'Level_0': max_price,
        'Level_1': max_price - 0.236 * difference,
        'Level_2': max_price - 0.382 * difference,
        'Level_3': max_price - 0.618 * difference,
        'Level_4': min_price
    }

    # Identify support and resistance levels
    support_levels = historical_data[historical_data['Low'] == min_price]['Low'].tolist()
    resistance_levels = historical_data[historical_data['High'] == max_price]['High'].tolist()

    # Print support, resistance levels, and Fibonacci levels
    print(f"Support Levels for {ticker_symbol}: {support_levels}")
    print(f"Resistance Levels for {ticker_symbol}: {resistance_levels}")
    print(f"Fibonacci Retracement Levels for {ticker_symbol}: {levels}")

    # Plot data
    plt.figure(figsize=(14, 7))

    # Plot Closing Prices
    plt.plot(historical_data['Close'], label='Close Price', color='blue')

    # Plot Moving Averages
    plt.plot(historical_data['Short_MA'], label='20-Day Moving Average', color='red')
    plt.plot(historical_data['Long_MA'], label='50-Day Moving Average', color='green')

    # Plot Fibonacci Levels
    for key, level in levels.items():
        plt.axhline(level, linestyle='--', alpha=0.5, label=f'Fibonacci {key} ({level:.2f})')

    # Highlight Support and Resistance Levels
    for support in support_levels:
        plt.axhline(support, linestyle='-', alpha=0.5, color='purple', label=f'Support Level ({support:.2f})')

    for resistance in resistance_levels:
        plt.axhline(resistance, linestyle='-', alpha=0.5, color='orange', label=f'Resistance Level ({resistance:.2f})')

    # Add labels and title
    plt.title(f"Stock Analysis for {ticker_symbol}")
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()
    plt.show()

# Input ticker symbol from the user
ticker_symbol = input("Enter the stock ticker symbol (e.g., TATASTEEL.NS for Tata Steel): ").upper()

# Call the function with user input
stock_analysis(ticker_symbol)

